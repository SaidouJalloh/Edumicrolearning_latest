// code qui marche super bien
// Scripts dispo en remote
// üéØ API PRINCIPALE - POST /ai/plan-to-markdown (VERSION D√âTAILL√âE)


// const express = require('express');
// const axios = require('axios');
// const { v4: uuidv4 } = require('uuid');
// const fs = require('fs').promises;
// const path = require('path');

// const router = express.Router();

// // ü§ñ Fonction Groq pour g√©n√©ration intelligente
// async function callGroq(prompt, options = {}) {
//     try {
//         // const response = await axios.post('https://api.groq.com/openai/v1/chat/completions', {
//         //     model: process.env.GROQ_MODEL || 'llama-3.3-70b-versatile',
//         const response = await axios.post('https://api.anthropic.com/v1/messages', {
//             model: process.env.CLAUDE_MODEL || 'claude-3-haiku-20240307',
//             messages: [
//                 {
//                     role: 'system',
//                     content: options.system_content || 'Tu es un expert Slidev qui cr√©e du Markdown sophistiqu√© en utilisant intelligemment les ressources fournies. R√©ponds UNIQUEMENT avec du Markdown Slidev valide.'
//                 },
//                 {
//                     role: 'user',
//                     content: prompt
//                 }
//             ],
//             temperature: options.temperature || 0.7,
//             max_tokens: options.max_tokens || 5000
//         }, {
//             headers: {
//                 'Authorization': `Bearer ${process.env.CLAUDE_MODEL}`,
//                 'Content-Type': 'application/json'
//             }
//         });

//         return response.data.choices[0].message.content;
//     } catch (error) {
//         console.error('‚ùå Erreur Groq:', error.message);
//         throw new Error('Erreur g√©n√©ration IA: ' + error.message);
//     }
// }

// // üéØ API PRINCIPALE - POST /ai/plan-to-markdown
// router.post('/plan-to-markdown', async (req, res) => {
//     const startTime = Date.now();

//     try {
//         // Validation de base
//         if (!req.body.plan_sections || !req.body.topic) {
//             return res.status(400).json({
//                 error: 'Format invalide',
//                 required: ['plan_sections', 'topic'],
//                 format: 'Utilisez TOUT le r√©sultat de POST /ai/groq-plan'
//             });
//         }

//         const groqPlanData = req.body;
//         console.log(`üìÑ G√©n√©ration Markdown enrichi: ${groqPlanData.topic}`);

//         // üîç ANALYSE DES RESSOURCES DISPONIBLES
//         const resourcesAnalysis = analyzeAvailableResources(groqPlanData);
//         console.log(`üìö Ressources d√©tect√©es: ${resourcesAnalysis.total_files} fichiers, vocabulaire: ${resourcesAnalysis.vocabulary_adapted}`);

//         // üé® G√âN√âRATION MARKDOWN ENRICHI
//         console.log('üé® G√©n√©ration Markdown Slidev enrichi...');
//         const markdownPrompt = createEnhancedMarkdownPrompt(groqPlanData, resourcesAnalysis);
//         const markdownResponse = await callGroq(markdownPrompt, {
//             temperature: 0.7,
//             max_tokens: 6000
//         });

//         let slideMarkdown = cleanMarkdown(markdownResponse);

//         // Fallback si n√©cessaire
//         if (!slideMarkdown.includes('---\ntheme:')) {
//             console.log('üîÑ G√©n√©ration fallback...');
//             slideMarkdown = createFallbackMarkdown(groqPlanData, resourcesAnalysis);
//         }

//         // üÜï COMPTER LES SLIDES R√âELLES DANS LE MARKDOWN
//         const actualSlideCount = countActualSlides(slideMarkdown);
//         console.log(`üìä Slides d√©tect√©es: ${actualSlideCount} (sections plan: ${groqPlanData.plan_sections.length})`);

//         // üîß G√âN√âRATION SCRIPT NARRATION AVEC SYNCHRONISATION
//         console.log('üé¨ G√©n√©ration script narration synchronis√©...');
//         const narrationPrompt = createNarrationPrompt(groqPlanData, resourcesAnalysis, actualSlideCount);
//         const narrationResponse = await callGroq(narrationPrompt, {
//             system_content: 'Tu es un expert en narration qui adapte le discours aux ressources. R√©ponds UNIQUEMENT avec du JSON valide avec le nombre exact de slides demand√©.',
//             max_tokens: 5000
//         });

//         let narrationScript;
//         try {
//             const cleanedNarration = cleanNarrationResponse(narrationResponse);
//             narrationScript = JSON.parse(cleanedNarration);

//             // üÜï VALIDATION SYNCHRONISATION
//             const scriptCount = Object.keys(narrationScript).length;
//             if (scriptCount !== actualSlideCount) {
//                 console.warn(`‚ö†Ô∏è D√©synchronisation d√©tect√©e: ${actualSlideCount} slides vs ${scriptCount} scripts`);
//                 // Forcer la synchronisation
//                 narrationScript = forceSynchronization(narrationScript, actualSlideCount, groqPlanData, resourcesAnalysis);
//             }

//         } catch (parseError) {
//             console.warn('‚ö†Ô∏è Erreur parsing narration, fallback synchronis√©...');
//             narrationScript = createSynchronizedFallbackNarration(groqPlanData, resourcesAnalysis, actualSlideCount);
//         }

//         // üÜï V√âRIFICATION FINALE
//         const finalSlideCount = actualSlideCount;
//         const finalScriptCount = Object.keys(narrationScript).length;

//         console.log(`‚úÖ Synchronisation finale: ${finalSlideCount} slides = ${finalScriptCount} scripts`);

//         // üèóÔ∏è ASSEMBLAGE FINAL
//         const slidesId = uuidv4();
//         const totalTime = Date.now() - startTime;

//         const result = {
//             slides_id: slidesId,

//             // R√âSULTATS PRINCIPAUX (Compatible format existant)
//             markdown: slideMarkdown,
//             narration_script: narrationScript,

//             // üÜï INFORMATIONS SYNCHRONISATION
//             synchronization_info: {
//                 markdown_slides_count: finalSlideCount,
//                 narration_scripts_count: finalScriptCount,
//                 synchronized: finalSlideCount === finalScriptCount,
//                 plan_sections_count: groqPlanData.plan_sections.length,
//                 mapping_type: finalSlideCount === groqPlanData.plan_sections.length ? '1:1' :
//                     finalSlideCount > groqPlanData.plan_sections.length ? 'expanded' : 'compressed'
//             },

//             // INFORMATIONS RESSOURCES
//             resource_integration: {
//                 files_used_in_markdown: resourcesAnalysis.files_content_integrated,
//                 company_context_applied: resourcesAnalysis.company_context_integrated,
//                 vocabulary_adapted: resourcesAnalysis.vocabulary_adapted,
//                 examples_from_files: resourcesAnalysis.extracted_examples,
//                 procedures_integrated: resourcesAnalysis.procedures_integrated,
//                 terminology_used: resourcesAnalysis.key_terminology
//             },

//             // COMPATIBILIT√â AVEC FORMAT EXISTANT
//             slides_count: finalSlideCount,
//             topic: groqPlanData.topic,
//             source_plan_id: groqPlanData.plan_id,

//             files: {
//                 markdown: `resource_slides_${slidesId}.md`,
//                 narration: `narration_${slidesId}.json`,
//                 script_txt: `script_${slidesId}.txt`
//             },

//             file_sizes: {
//                 markdown_kb: Math.round(slideMarkdown.length / 1024),
//                 narration_kb: Math.round(JSON.stringify(narrationScript).length / 1024)
//             },

//             slidev_commands: {
//                 preview: `slidev resource_slides_${slidesId}.md`,
//                 export_pdf: `slidev export resource_slides_${slidesId}.md --format pdf`,
//                 export_html: `slidev export resource_slides_${slidesId}.md --format html`
//             },

//             video_production: {
//                 total_duration_seconds: Object.values(narrationScript).reduce((sum, script) => sum + script.duration_seconds, 0),
//                 slides_with_timing: Object.keys(narrationScript).length,
//                 ready_for_recording: true,
//                 uses_company_terminology: resourcesAnalysis.vocabulary_adapted,
//                 references_uploaded_files: resourcesAnalysis.files_content_integrated,
//                 perfectly_synchronized: true
//             },

//             generation_time_ms: totalTime,
//             generated_at: new Date().toISOString(),
//             status: 'completed',
//             ready_for_production: true,

//             next_steps: {
//                 audio_generation: 'POST /ai/generate-narration-bark avec script synchronis√©',
//                 customization: resourcesAnalysis.company_context_integrated ?
//                     'Contenu d√©j√† adapt√© √† votre contexte' :
//                     'Personnaliser selon votre contexte'
//             }
//         };

//         console.log(`‚úÖ G√©n√©ration compl√®te: ${finalSlideCount} slides synchronis√©es, ${resourcesAnalysis.total_files} fichiers int√©gr√©s, ${totalTime}ms`);
//         res.json(result);

//     } catch (error) {
//         const totalTime = Date.now() - startTime;
//         console.error('‚ùå Erreur plan-to-markdown:', error);
//         res.status(500).json({
//             error: 'Erreur g√©n√©ration markdown',
//             generation_time_ms: totalTime,
//             details: error.message
//         });
//     }
// });

// // üÜï FONCTIONS DE SYNCHRONISATION

// function countActualSlides(markdown) {
//     // Compter le nombre de slides r√©elles dans le markdown
//     const slidesSeparators = markdown.match(/^---$/gm) || [];

//     // Le premier --- est pour les m√©tadonn√©es, donc slides = separators - 1
//     let slideCount = Math.max(1, slidesSeparators.length - 1);

//     // Validation suppl√©mentaire avec les layouts
//     const layoutsFound = markdown.match(/layout:\s*(intro|default|two-cols|center|end)/g) || [];

//     // Si on trouve des layouts, utiliser ce nombre
//     if (layoutsFound.length > 0) {
//         slideCount = Math.max(slideCount, layoutsFound.length);
//     }

//     // Compter aussi les titres de slides (# titre)
//     const titleSlides = markdown.match(/^#\s+.+$/gm) || [];
//     if (titleSlides.length > slideCount) {
//         slideCount = titleSlides.length;
//     }

//     console.log(`üìä D√©tection slides: separators=${slidesSeparators.length - 1}, layouts=${layoutsFound.length}, titles=${titleSlides.length}, final=${slideCount}`);

//     return Math.max(slideCount, 1);
// }

// function forceSynchronization(narrationScript, targetCount, planData, resourcesAnalysis) {
//     const currentCount = Object.keys(narrationScript).length;

//     if (currentCount === targetCount) {
//         return narrationScript; // D√©j√† synchronis√©
//     }

//     console.log(`üîß For√ßage synchronisation: ${currentCount} ‚Üí ${targetCount} scripts`);

//     // Cr√©er nouveau script synchronis√©
//     return createSynchronizedFallbackNarration(planData, resourcesAnalysis, targetCount);
// }

// function createSynchronizedFallbackNarration(planData, resourcesAnalysis, slideCount) {
//     const { plan_sections } = planData;
//     const narration = {};

//     console.log(`üîß Cr√©ation narration synchronis√©e: ${slideCount} scripts pour ${plan_sections.length} sections`);

//     for (let i = 0; i < slideCount; i++) {
//         const slideKey = `slide_${i + 1}`;

//         // Mapping intelligent sections ‚Üí slides
//         let mappedSection;
//         let sectionIndex;

//         if (slideCount <= plan_sections.length) {
//             // Moins ou √©gal de slides que de sections ‚Üí mapping direct ou combinaison
//             sectionIndex = Math.floor(i * plan_sections.length / slideCount);
//         } else {
//             // Plus de slides que de sections ‚Üí subdivision
//             sectionIndex = Math.floor(i * plan_sections.length / slideCount);
//         }

//         mappedSection = plan_sections[Math.min(sectionIndex, plan_sections.length - 1)];

//         let tone = 'p√©dagogique';
//         let title = mappedSection.title;
//         let script = `Nous allons maintenant aborder ${mappedSection.title}.`;

//         // D√©finir le ton selon la position
//         if (i === 0) {
//             tone = 'accueillant';
//             title = mappedSection.title || 'Introduction';
//             script = resourcesAnalysis.files_content_integrated ?
//                 `Bonjour et bienvenue dans cette formation sur ${title}, adapt√©e √† vos documents.` :
//                 `Bonjour et bienvenue dans cette formation sur ${title}.`;
//         } else if (i === slideCount - 1) {
//             tone = 'motivant';
//             title = 'Conclusion';
//             script = 'Pour conclure, retenez bien les points essentiels que nous venons de voir.';
//         } else {
//             // Slide interm√©diaire
//             if (slideCount > plan_sections.length) {
//                 // Subdivision d'une section
//                 const partNumber = Math.floor(i / (slideCount / plan_sections.length)) + 1;
//                 title = `${mappedSection.title} - Partie ${partNumber}`;
//                 script = `Continuons avec ${mappedSection.title}. Nous allons maintenant voir les d√©tails importants.`;
//             }
//         }

//         // Calculer dur√©e proportionnelle
//         const baseDuration = mappedSection.duration_seconds || 60;
//         const proportionalDuration = Math.floor(baseDuration * (plan_sections.length / slideCount));
//         const adjustedDuration = Math.max(15, Math.min(120, proportionalDuration)); // Entre 15s et 2min

//         narration[slideKey] = {
//             title: title,
//             duration_seconds: adjustedDuration,
//             script: script,
//             tone: tone,
//             key_phrases: resourcesAnalysis.key_terminology.slice(0, 2) || ["Point important"],
//             uses_resources: resourcesAnalysis.files_content_integrated,
//             mapped_from_section: sectionIndex + 1,
//             slide_position: i + 1,
//             auto_generated: true // Flag pour indiquer g√©n√©ration automatique
//         };
//     }

//     return narration;
// }

// // üîç ANALYSE DES RESSOURCES DISPONIBLES
// function analyzeAvailableResources(groqPlanData) {
//     const analysis = {
//         total_files: 0,
//         files_content_integrated: false,
//         company_context_integrated: false,
//         vocabulary_adapted: false,
//         procedures_integrated: false,
//         examples_extracted: false,
//         key_terminology: [],
//         extracted_examples: [],
//         file_references: [],
//         adaptation_quality: 'basic'
//     };

//     // Analyser les fichiers trait√©s
//     if (groqPlanData.files_processing) {
//         analysis.total_files = groqPlanData.files_processing.processed_successfully || 0;
//         analysis.files_content_integrated = analysis.total_files > 0;

//         if (groqPlanData.files_processing.processed_files) {
//             groqPlanData.files_processing.processed_files.forEach(file => {
//                 if (file.status === 'parsed') {
//                     analysis.file_references.push({
//                         name: file.name,
//                         type: file.content_type,
//                         topics: file.key_topics
//                     });

//                     if (file.has_procedures) analysis.procedures_integrated = true;
//                     if (file.has_examples) analysis.examples_extracted = true;
//                     if (file.key_topics) analysis.key_terminology.push(...file.key_topics);
//                 }
//             });
//         }
//     }

//     // Analyser l'enrichissement
//     if (groqPlanData.resources_enrichment) {
//         analysis.company_context_integrated = groqPlanData.resources_enrichment.has_company_context;
//         analysis.vocabulary_adapted = groqPlanData.resources_enrichment.adaptation_applied?.vocabulary_adapted || false;
//     }

//     // Extraire des sections du plan
//     if (groqPlanData.plan_sections) {
//         groqPlanData.plan_sections.forEach(section => {
//             if (section.enhanced_with_resources) {
//                 if (section.key_terminology) {
//                     analysis.key_terminology.push(...section.key_terminology);
//                 }
//                 if (section.examples_from_resources) {
//                     analysis.extracted_examples.push(...section.examples_from_resources);
//                 }
//             }
//         });
//     }

//     // D√©duplication
//     analysis.key_terminology = [...new Set(analysis.key_terminology.flat())].slice(0, 10);
//     analysis.extracted_examples = [...new Set(analysis.extracted_examples.flat())].slice(0, 8);

//     // Calcul qualit√©
//     if (analysis.files_content_integrated && analysis.vocabulary_adapted && analysis.company_context_integrated) {
//         analysis.adaptation_quality = 'excellent';
//     } else if (analysis.files_content_integrated || analysis.vocabulary_adapted) {
//         analysis.adaptation_quality = 'good';
//     }

//     return analysis;
// }

// // üé® CR√âATION PROMPT MARKDOWN ENRICHI - VERSION CORRIG√âE
// // üé® CR√âATION PROMPT MARKDOWN ENRICHI - VERSION CORRIG√âE
// function createEnhancedMarkdownPrompt(planData, resourcesAnalysis) {
//     const { topic, plan_sections, settings } = planData;
//     const { level = 'beginner', duration = 5, style = 'practical' } = settings || {};

//     let prompt = `Cr√©e un Markdown Slidev sophistiqu√© qui utilise les ressources fournies:

// INFORMATIONS:
// - Sujet: ${topic}
// - Niveau: ${level}
// - Dur√©e: ${duration} minutes
// - Style: ${style}

// RESSOURCES DISPONIBLES:
// - Fichiers trait√©s: ${resourcesAnalysis.total_files}
// - Contexte entreprise: ${resourcesAnalysis.company_context_integrated ? 'OUI' : 'NON'}
// - Vocabulaire adapt√©: ${resourcesAnalysis.vocabulary_adapted ? 'OUI' : 'NON'}
// - Proc√©dures: ${resourcesAnalysis.procedures_integrated ? 'OUI' : 'NON'}
// - Exemples: ${resourcesAnalysis.examples_extracted ? 'OUI' : 'NON'}`;

//     if (resourcesAnalysis.key_terminology.length > 0) {
//         prompt += `\n\nTERMINOLOGIE √Ä UTILISER:\n${resourcesAnalysis.key_terminology.join(', ')}`;
//     }

//     if (resourcesAnalysis.extracted_examples.length > 0) {
//         prompt += `\n\nEXEMPLES √Ä INT√âGRER:\n${resourcesAnalysis.extracted_examples.map((ex, i) => `${i + 1}. ${ex}`).join('\n')}`;
//     }

//     if (resourcesAnalysis.file_references.length > 0) {
//         prompt += `\n\nFICHIERS √Ä R√âF√âRENCER:\n${resourcesAnalysis.file_references.map(ref => `- ${ref.name}: ${ref.type}`).join('\n')}`;
//     }

//     prompt += `\n\nSECTIONS DU PLAN:\n${plan_sections.map((section, i) => {
//         return `${i + 1}. ${section.title} (${section.duration_seconds}s)\n   Points: ${section.what_to_cover ? section.what_to_cover.join(', ') : '√Ä d√©velopper'}`;
//     }).join('\n\n')}`;

//     prompt += `\n\nG√âN√àRE un Markdown Slidev enrichi avec int√©gration des ressources:

// ---
// theme: ${resourcesAnalysis.company_context_integrated ? 'corporate' : 'academic'}
// background: linear-gradient(135deg, #667eea 0%, #764ba2 100%)
// class: text-center
// highlighter: shiki
// lineNumbers: true
// title: ${topic}
// ---

// # ${topic}
// ## Formation ${duration} minutes${resourcesAnalysis.company_context_integrated ? ' - Adapt√©e √† votre contexte' : ''}

// ${resourcesAnalysis.files_content_integrated ? `
// <div class="opacity-80 text-sm mt-4 bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg">
//   üìö Formation enrichie par ${resourcesAnalysis.total_files} document(s)
// </div>
// ` : ''}

// <div class="pt-8">
//   <span @click="$slidev.nav.next" class="px-6 py-3 rounded-lg cursor-pointer bg-gradient-to-r from-blue-500 to-purple-600 text-white font-semibold">
//     üöÄ Commencer
//   </span>
// </div>

// ${plan_sections.map((section, index) => {
//         if (section.type === 'introduction') {
//             return `
// ---
// layout: intro
// ---

// # ${section.title}

// ${section.what_to_cover ? section.what_to_cover.map(point => `- **${point}**`).join('\n') : '- Introduction au sujet'}

// ${section.enhanced_with_resources && resourcesAnalysis.extracted_examples.length > 0 ? `
// <div class="mt-6 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
//   <h3 class="text-lg font-semibold mb-3 text-blue-700 dark:text-blue-300">
//     üí° Bas√© sur vos ressources
//   </h3>
//   <div class="text-sm space-y-2">
// ${resourcesAnalysis.extracted_examples.slice(0, 2).map(example => `    <div>‚Ä¢ ${example}</div>`).join('\n')}
//   </div>
// </div>
// ` : ''}

// <div class="mt-6">
//   <div class="px-4 py-2 rounded-full bg-blue-100 text-blue-800 text-sm inline-block">
//     ‚è±Ô∏è ${section.duration_seconds}s
//   </div>
// </div>`;

//         } else if (section.type === 'development') {
//             // üöÄ CORRECTION PRINCIPALE - Layout default au lieu de two-cols probl√©matique
//             return `
// ---
// layout: default
// ---

// # ${section.title}

// <div class="grid grid-cols-2 gap-8 mt-8">

// <div class="space-y-4">

// ${section.what_to_cover ? section.what_to_cover.map((point, i) => `
// ## ${i + 1}. ${point}

// ${section.enhanced_with_resources ? `
// <div class="text-sm text-blue-600 mb-4 bg-blue-50 p-2 rounded">
//   üí° Point enrichi par vos documents
// </div>
// ` : `
// <div class="text-gray-600 text-sm mb-4">
//   Point essentiel √† retenir
// </div>
// `}
// `).join('') : '## Contenu principal'}

// </div>

// <div class="h-full">

// ${section.enhanced_with_resources && resourcesAnalysis.extracted_examples.length > 0 ? `
// <div class="bg-green-50 p-6 rounded-xl h-full">
//   <h3 class="text-lg font-semibold mb-4 text-green-700">
//     üìã Exemples de vos documents
//   </h3>
//   <div class="space-y-3">
// ${resourcesAnalysis.extracted_examples.slice(0, 3).map(example => `    <div class="bg-white p-3 rounded-lg">
//       <div class="text-sm">${example}</div>
//     </div>`).join('\n')}
//   </div>
// </div>
// ` : `
// <div class="bg-orange-50 p-6 rounded-xl h-full">
//   <h3 class="text-lg font-semibold mb-2">Points Cl√©s</h3>
//   <div class="text-sm">${section.content_summary || 'Contenu adapt√©'}</div>
// </div>
// `}

// </div>

// </div>

// <div class="mt-8 p-4 bg-blue-50 rounded-lg">
//   <div class="font-semibold">R√©sum√©</div>
//   <div class="text-sm mt-1">${section.content_summary || 'Points cl√©s de cette section'}</div>
// </div>`;

//         } else if (section.type === 'conclusion') {
//             return `
// ---
// layout: center
// class: text-center
// ---

// # ${section.title}

// <div class="max-w-4xl mx-auto">
//   <div class="grid grid-cols-1 md:grid-cols-${section.what_to_cover ? Math.min(section.what_to_cover.length, 3) : 2} gap-6 mb-8">
// ${section.what_to_cover ? section.what_to_cover.map(point => `    <div class="bg-green-50 p-6 rounded-xl">
//       <div class="text-3xl mb-3">‚úÖ</div>
//       <div class="font-semibold text-green-700">${point}</div>
//     </div>`).join('\n') : `    <div class="bg-green-50 p-6 rounded-xl">
//       <div class="text-4xl mb-3">‚úÖ</div>
//       <div class="font-semibold">R√©capitulatif</div>
//     </div>
//     <div class="bg-blue-50 p-6 rounded-xl">
//       <div class="text-4xl mb-3">üöÄ</div>
//       <div class="font-semibold">Prochaines √âtapes</div>
//     </div>`}
//   </div>

//   ${section.enhanced_with_resources ? `
//   <div class="bg-purple-100 p-6 rounded-xl mb-8">
//     <h3 class="text-xl font-semibold mb-4 text-purple-700">
//       üéØ Applications dans votre contexte
//     </h3>
//     <div class="text-sm text-purple-600">
//       Cette formation a √©t√© adapt√©e √† vos ressources.
//     </div>
//   </div>
//   ` : ''}

//   <div class="pt-8">
//     <span class="px-8 py-4 rounded-xl bg-gradient-to-r from-green-400 to-blue-500 text-white font-bold text-xl">
//       üéâ Formation Termin√©e !
//     </span>
//   </div>
// </div>`;
//         }
//         return '';
//     }).join('')}

// ---
// layout: end
// ---

// # Merci !

// <div class="text-center">
//   <div class="text-6xl mb-4">üéâ</div>
//   <div class="text-2xl">Formation ${topic} termin√©e</div>
//   ${resourcesAnalysis.files_content_integrated ? `
//   <div class="text-lg text-blue-600 mt-2">
//     üìö Avec ${resourcesAnalysis.total_files} document(s) int√©gr√©(s)
//   </div>
//   ` : `
//   <div class="text-lg text-gray-600 mt-2">Dur√©e: ${duration} minutes</div>
//   `}
// </div>

// G√©n√®re UNIQUEMENT ce Markdown, rien d'autre.`;

//     return prompt;
// }
// // üé¨ CR√âATION PROMPT NARRATION SYNCHRONIS√â
// function createNarrationPrompt(planData, resourcesAnalysis, actualSlideCount) {
//     const { topic, plan_sections, settings } = planData;
//     const { level = 'beginner', duration = 5 } = settings || {};

//     let prompt = `Cr√©e un script de narration adapt√© aux ressources et PARFAITEMENT synchronis√©:

// FORMATION:
// - Sujet: ${topic}
// - Niveau: ${level}
// - Dur√©e: ${duration} minutes
// - NOMBRE DE SLIDES EXACT: ${actualSlideCount}

// ADAPTATION RESSOURCES:
// - Fichiers: ${resourcesAnalysis.total_files}
// - Vocabulaire adapt√©: ${resourcesAnalysis.vocabulary_adapted ? 'OUI' : 'NON'}
// - Exemples sp√©cifiques: ${resourcesAnalysis.examples_extracted ? 'OUI' : 'NON'}`;

//     if (resourcesAnalysis.key_terminology.length > 0) {
//         prompt += `\n\nTERMINOLOGIE √Ä UTILISER: ${resourcesAnalysis.key_terminology.join(', ')}`;
//     }

//     prompt += `\n\nSECTIONS DISPONIBLES:\n${plan_sections.map((section, i) =>
//         `${i + 1}. ${section.title} (${section.duration_seconds}s) - ${section.type}`
//     ).join('\n')}`;

//     prompt += `\n\n‚ö†Ô∏è CRITICAL: Tu dois g√©n√©rer EXACTEMENT ${actualSlideCount} scripts de narration.

// R√àGLES DE MAPPING:
// - Si ${actualSlideCount} slides > ${plan_sections.length} sections : Diviser les sections longues
// - Si ${actualSlideCount} slides < ${plan_sections.length} sections : Combiner certaines sections  
// - Si ${actualSlideCount} slides = ${plan_sections.length} sections : Mapping 1:1 parfait

// G√âN√àRE ce JSON avec EXACTEMENT ${actualSlideCount} entr√©es:

// {
// ${Array.from({ length: actualSlideCount }, (_, index) => {
//         const slideKey = `slide_${index + 1}`;
//         let sectionIndex;

//         if (actualSlideCount <= plan_sections.length) {
//             sectionIndex = Math.floor(index * plan_sections.length / actualSlideCount);
//         } else {
//             sectionIndex = Math.floor(index * plan_sections.length / actualSlideCount);
//         }

//         const mappedSection = plan_sections[Math.min(sectionIndex, plan_sections.length - 1)];

//         let tone = 'p√©dagogique';
//         let title = mappedSection.title;

//         if (index === 0) {
//             tone = 'accueillant';
//             title = mappedSection.title || 'Introduction';
//         } else if (index === actualSlideCount - 1) {
//             tone = 'motivant';
//             title = 'Conclusion';
//         } else if (actualSlideCount > plan_sections.length) {
//             const partNumber = Math.floor((index - 1) / Math.ceil(actualSlideCount / plan_sections.length)) + 1;
//             title = `${mappedSection.title} - Partie ${partNumber}`;
//         }

//         const baseDuration = mappedSection.duration_seconds || 60;
//         const proportionalDuration = Math.floor(baseDuration * (plan_sections.length / actualSlideCount));
//         const adjustedDuration = Math.max(15, Math.min(120, proportionalDuration));

//         return `  "${slideKey}": {
//     "title": "${title}",
//     "duration_seconds": ${adjustedDuration},
//     "script": "Script adapt√© pour ${title}. ${resourcesAnalysis.vocabulary_adapted ? 'Utiliser la terminologie sp√©cialis√©e.' : ''} ${resourcesAnalysis.examples_extracted ? 'Mentionner les exemples des documents.' : ''}",
//     "tone": "${tone}",
//     "key_phrases": ${resourcesAnalysis.key_terminology.length > 0 ? JSON.stringify(resourcesAnalysis.key_terminology.slice(0, 2)) : '["point important"]'},
//     "uses_resources": ${resourcesAnalysis.files_content_integrated}
//   }`;
//     }).join(',\n')}
// }

// R√àGLES:
// - Ton naturel et ${resourcesAnalysis.company_context_integrated ? 'professionnel' : 'conversationnel'}
// - ${resourcesAnalysis.vocabulary_adapted ? 'Utiliser OBLIGATOIREMENT la terminologie fournie' : 'Langage accessible'}
// - ${resourcesAnalysis.examples_extracted ? 'Int√©grer les exemples des documents' : 'Exemples g√©n√©riques'}

// G√©n√®re UNIQUEMENT ce JSON avec EXACTEMENT ${actualSlideCount} scripts, rien d'autre.`;

//     return prompt;
// }

// // üîß FONCTIONS UTILITAIRES

// function cleanMarkdown(markdown) {
//     return markdown
//         .replace(/```markdown\n/g, '')
//         .replace(/\n```/g, '')
//         .replace(/```/g, '')
//         .trim();
// }

// function cleanNarrationResponse(response) {
//     return response
//         .replace(/```json\n/g, '')
//         .replace(/\n```/g, '')
//         .replace(/```/g, '')
//         .replace(/^[^{]*/, '')
//         .replace(/[^}]*$/, '')
//         .trim();
// }

// // üîß CR√âATION FALLBACK MARKDOWN CORRIG√â
// // üîß CR√âATION FALLBACK MARKDOWN CORRIG√â
// function createFallbackMarkdown(planData, resourcesAnalysis) {
//     const { topic, plan_sections, settings } = planData;
//     const { duration = 5 } = settings || {};

//     return `---
// theme: academic
// background: linear-gradient(45deg, #1e3c72, #2a5298)
// class: text-center
// title: ${topic}
// ---

// # ${topic}
// ## Formation ${duration} minutes

// ${resourcesAnalysis.files_content_integrated ? `
// <div class="text-sm mt-4 bg-blue-50 p-3 rounded">
//   üìö Formation enrichie par ${resourcesAnalysis.total_files} document(s)
// </div>
// ` : ''}

// <div class="pt-12">
//   <span @click="$slidev.nav.next" class="px-6 py-3 rounded-lg cursor-pointer bg-blue-600 text-white">
//     üöÄ Commencer
//   </span>
// </div>

// ${plan_sections.map(section => {
//         // üöÄ CORRECTION - Utiliser layout default avec structure correcte
//         return `
// ---
// layout: default
// ---

// # ${section.title}

// <div class="max-w-4xl mx-auto mt-8">

// <div class="space-y-6">
// ${section.what_to_cover ? section.what_to_cover.map(point => `
// <div class="bg-white p-4 rounded-lg border-l-4 border-blue-500">
//   <div class="font-semibold text-gray-800">‚Ä¢ ${point}</div>
// </div>`).join('') : `
// <div class="bg-white p-4 rounded-lg border-l-4 border-blue-500">
//   <div class="font-semibold text-gray-800">‚Ä¢ Contenu √† d√©velopper</div>
// </div>`}
// </div>

// ${section.enhanced_with_resources ? `
// <div class="mt-8 p-6 bg-blue-50 rounded-xl">
//   <h3 class="text-lg font-semibold mb-2 text-blue-700">üí° Adapt√© √† vos ressources</h3>
//   <div class="text-sm text-blue-600">${section.content_summary || 'Contenu personnalis√©'}</div>
// </div>
// ` : `
// <div class="mt-8 p-4 bg-gray-50 rounded-lg">
//   <div class="text-sm text-gray-600">
//     ‚è±Ô∏è ${section.duration_seconds}s ‚Ä¢ ${section.type}
//   </div>
// </div>
// `}

// </div>`;
//     }).join('')}

// ---
// layout: end
// ---

// # Merci !

// <div class="text-center">
//   <div class="text-6xl mb-4">üéâ</div>
//   <div class="text-2xl">Formation ${topic} termin√©e</div>
//   <div class="text-lg text-gray-600 mt-2">Dur√©e: ${duration} minutes</div>
// </div>`;
// }

// // üîß ROUTE SAUVEGARDE
// router.post('/save-files', async (req, res) => {
//     try {
//         const { markdown, narration_script, slides_id } = req.body;

//         if (!markdown) {
//             return res.status(400).json({
//                 error: 'Le champ "markdown" est requis'
//             });
//         }

//         const slidesDir = path.join(__dirname, '..', '..', 'generated-slides');
//         await fs.mkdir(slidesDir, { recursive: true });

//         const baseFilename = slides_id || `resource_slides_${Date.now()}`;
//         const savedFiles = [];

//         // Sauvegarder markdown
//         const markdownFile = `${baseFilename}.md`;
//         const markdownPath = path.join(slidesDir, markdownFile);
//         await fs.writeFile(markdownPath, markdown, 'utf8');
//         savedFiles.push(markdownFile);

//         // Sauvegarder script narration
//         if (narration_script) {
//             const narrationFile = `narration_${baseFilename}.json`;
//             const narrationPath = path.join(slidesDir, narrationFile);
//             await fs.writeFile(narrationPath, JSON.stringify(narration_script, null, 2), 'utf8');
//             savedFiles.push(narrationFile);

//             // Script texte
//             const scriptText = Object.entries(narration_script)
//                 .map(([slide, data]) => `=== ${data.title} (${data.duration_seconds}s) ===\n${data.script}\n`)
//                 .join('\n');

//             const scriptFile = `script_${baseFilename}.txt`;
//             const scriptPath = path.join(slidesDir, scriptFile);
//             await fs.writeFile(scriptPath, scriptText, 'utf8');
//             savedFiles.push(scriptFile);
//         }

//         res.json({
//             message: 'Fichiers sauv√©s avec succ√®s',
//             saved_files: savedFiles,
//             directory: slidesDir,
//             slidev_command: `cd generated-slides && slidev ${markdownFile}`
//         });

//     } catch (error) {
//         res.status(500).json({
//             error: 'Erreur sauvegarde',
//             details: error.message
//         });
//     }
// });

// // üîß ROUTE INFO
// router.get('/plan-to-markdown/info', (req, res) => {
//     res.json({
//         endpoint: 'POST /ai/plan-to-markdown',
//         description: 'Convertit le plan en Markdown Slidev enrichi avec synchronisation parfaite slides/narration',
//         version: '5.1 - Perfect Synchronization + Two-Cols Fix',
//         status: '‚úÖ OP√âRATIONNEL',

//         fonctionnalit√©s: [
//             'üîÑ Synchronisation automatique slides ‚Üî scripts narration',
//             'üìö Utilisation intelligente des fichiers upload√©s',
//             'üé¨ Scripts de narration adapt√©s au vocabulaire',
//             'üè¢ Adaptation automatique au contexte entreprise',
//             'üîë Int√©gration terminologie sp√©cifique',
//             'üí° Exemples personnalis√©s des documents',
//             'üìä Validation et correction automatique des d√©synchronisations',
//             'üîß Correction structure two-cols Slidev'
//         ],

//         synchronization_features: [
//             '‚úÖ D√©tection automatique du nombre de slides markdown',
//             'üîß Ajustement forc√© du nombre de scripts narration',
//             'üìà Mapping intelligent sections ‚Üí slides',
//             '‚öñÔ∏è R√©partition proportionnelle des dur√©es',
//             'üîç Validation finale de synchronisation'
//         ],

//         slidev_fixes: [
//             'üîß Correction structure two-cols: titres dans les slots',
//             '‚úÖ Respect des templates v-slot:default et v-slot:right',
//             'üõ°Ô∏è Pr√©vention erreurs Vue.js Slidev',
//             'üìè G√©n√©ration correcte du nombre de slides'
//         ],

//         workflow: [
//             '1. POST /ai/groq-plan (avec ressources/fichiers)',
//             '2. POST /ai/plan-to-markdown (g√©n√®re markdown + compte slides)',
//             '3. G√©n√©ration narration avec nombre exact de scripts',
//             '4. Validation synchronisation finale',
//             '5. POST /ai/generate-narration-bark (audio parfaitement align√©)'
//         ],

//         mapping_strategies: {
//             one_to_one: 'Slides = Sections ‚Üí Mapping direct 1:1',
//             expansion: 'Slides > Sections ‚Üí Subdivision intelligente',
//             compression: 'Slides < Sections ‚Üí Combinaison logique'
//         },

//         compatibilit√©: {
//             format_entr√©e: 'Compatible avec tous les plans de groq-plan',
//             format_sortie: 'Compatible avec ancien format + enrichissements + sync info',
//             r√©trocompatible: 'Fonctionne avec plans sans ressources',
//             guaranteed_sync: 'Synchronisation garantie √† 100%',
//             slidev_compliant: 'Markdown Slidev valide sans erreurs Vue.js'
//         },

//         response_additions: {
//             synchronization_info: 'D√©tails de synchronisation et mapping',
//             perfectly_synchronized: 'Flag confirmant la synchronisation',
//             mapping_type: 'Type de mapping appliqu√© (1:1, expanded, compressed)'
//         },

//         exemples_int√©gration: {
//             fichier_excel: 'Guide Excel ‚Üí terminologie VLOOKUP, TCD dans slides + scripts',
//             proc√©dures: 'Proc√©dures d√©tect√©es ‚Üí r√©f√©rences dans markdown + narration',
//             contexte_entreprise: 'Contexte fourni ‚Üí adaptation ton professionnel',
//             exemples_sp√©cifiques: 'Exemples extraits ‚Üí int√©gration dans slides + scripts'
//         }
//     });
// });

// // üß™ ROUTE DE TEST SYNCHRONISATION
// router.post('/test-synchronization', async (req, res) => {
//     try {
//         const { markdown, plan_sections } = req.body;

//         if (!markdown || !plan_sections) {
//             return res.status(400).json({
//                 error: 'markdown et plan_sections requis'
//             });
//         }

//         const slideCount = countActualSlides(markdown);
//         const sectionCount = plan_sections.length;

//         // Test de synchronisation
//         const mockResourcesAnalysis = {
//             total_files: 0,
//             vocabulary_adapted: false,
//             files_content_integrated: false,
//             key_terminology: [],
//             extracted_examples: []
//         };

//         const syncedNarration = createSynchronizedFallbackNarration(
//             { plan_sections },
//             mockResourcesAnalysis,
//             slideCount
//         );

//         res.json({
//             test_results: {
//                 detected_slides: slideCount,
//                 plan_sections: sectionCount,
//                 generated_scripts: Object.keys(syncedNarration).length,
//                 synchronized: Object.keys(syncedNarration).length === slideCount
//             },
//             mapping_analysis: {
//                 type: slideCount === sectionCount ? '1:1' :
//                     slideCount > sectionCount ? 'expansion' : 'compression',
//                 ratio: Math.round((slideCount / sectionCount) * 100) / 100
//             },
//             generated_narration: syncedNarration,
//             success: true
//         });

//     } catch (error) {
//         res.status(500).json({
//             error: 'Erreur test synchronisation',
//             details: error.message
//         });
//     }
// });

// module.exports = router;


















// new code avec claude
const express = require('express');
const axios = require('axios');
const { v4: uuidv4 } = require('uuid');
const fs = require('fs').promises;
const path = require('path');

const router = express.Router();

// ü§ñ Fonction Claude pour g√©n√©ration intelligente
async function callClaude(prompt, options = {}) {
    try {
        const response = await axios.post('https://api.anthropic.com/v1/messages', {
            model: process.env.CLAUDE_MODEL || 'claude-3-haiku-20240307',
            max_tokens: options.max_tokens || 5000,
            temperature: options.temperature || 0.7,
            messages: [
                {
                    role: 'user',
                    content: options.system_content ?
                        `${options.system_content}\n\n${prompt}` :
                        prompt
                }
            ]
        }, {
            headers: {
                'x-api-key': process.env.CLAUDE_API_KEY,
                'content-type': 'application/json',
                'anthropic-version': '2023-06-01'
            }
        });

        return response.data.content[0].text;
    } catch (error) {
        console.error('‚ùå Erreur Claude:', error.response?.data || error.message);
        throw new Error('Erreur g√©n√©ration IA: ' + (error.response?.data?.error?.message || error.message));
    }
}

// üéØ API PRINCIPALE - POST /ai/plan-to-markdown
router.post('/plan-to-markdown', async (req, res) => {
    const startTime = Date.now();

    try {
        // Validation de base
        if (!req.body.plan_sections || !req.body.topic) {
            return res.status(400).json({
                error: 'Format invalide',
                required: ['plan_sections', 'topic'],
                format: 'Utilisez TOUT le r√©sultat de POST /ai/groq-plan'
            });
        }

        const planData = req.body;
        console.log(`üìÑ G√©n√©ration Markdown enrichi: ${planData.topic}`);

        // üîç ANALYSE DES RESSOURCES DISPONIBLES
        const resourcesAnalysis = analyzeAvailableResources(planData);
        console.log(`üìö Ressources d√©tect√©es: ${resourcesAnalysis.total_files} fichiers, vocabulaire: ${resourcesAnalysis.vocabulary_adapted}`);

        // üé® G√âN√âRATION MARKDOWN ENRICHI
        console.log('üé® G√©n√©ration Markdown Slidev enrichi...');
        const markdownPrompt = createEnhancedMarkdownPrompt(planData, resourcesAnalysis);
        const systemContent = 'Tu es un expert Slidev qui cr√©e du Markdown sophistiqu√© en utilisant intelligemment les ressources fournies. R√©ponds UNIQUEMENT avec du Markdown Slidev valide.';

        const markdownResponse = await callClaude(markdownPrompt, {
            system_content: systemContent,
            temperature: 0.7,
            max_tokens: 6000
        });

        let slideMarkdown = cleanMarkdown(markdownResponse);

        // Fallback si n√©cessaire
        if (!slideMarkdown.includes('---\ntheme:')) {
            console.log('üîÑ G√©n√©ration fallback...');
            slideMarkdown = createFallbackMarkdown(planData, resourcesAnalysis);
        }

        // üÜï COMPTER LES SLIDES R√âELLES DANS LE MARKDOWN
        const actualSlideCount = countActualSlides(slideMarkdown);
        console.log(`üìä Slides d√©tect√©es: ${actualSlideCount} (sections plan: ${planData.plan_sections.length})`);

        // üîß G√âN√âRATION SCRIPT NARRATION AVEC SYNCHRONISATION
        console.log('üé¨ G√©n√©ration script narration synchronis√©...');
        const narrationPrompt = createNarrationPrompt(planData, resourcesAnalysis, actualSlideCount);
        const narrationSystemContent = 'Tu es un expert en narration qui adapte le discours aux ressources. R√©ponds UNIQUEMENT avec du JSON valide avec le nombre exact de slides demand√©.';

        const narrationResponse = await callClaude(narrationPrompt, {
            system_content: narrationSystemContent,
            max_tokens: 5000
        });

        let narrationScript;
        try {
            const cleanedNarration = cleanNarrationResponse(narrationResponse);
            narrationScript = JSON.parse(cleanedNarration);

            // üÜï VALIDATION SYNCHRONISATION
            const scriptCount = Object.keys(narrationScript).length;
            if (scriptCount !== actualSlideCount) {
                console.warn(`‚ö†Ô∏è D√©synchronisation d√©tect√©e: ${actualSlideCount} slides vs ${scriptCount} scripts`);
                // Forcer la synchronisation
                narrationScript = forceSynchronization(narrationScript, actualSlideCount, planData, resourcesAnalysis);
            }

        } catch (parseError) {
            console.warn('‚ö†Ô∏è Erreur parsing narration, fallback synchronis√©...');
            narrationScript = createSynchronizedFallbackNarration(planData, resourcesAnalysis, actualSlideCount);
        }

        // üÜï V√âRIFICATION FINALE
        const finalSlideCount = actualSlideCount;
        const finalScriptCount = Object.keys(narrationScript).length;

        console.log(`‚úÖ Synchronisation finale: ${finalSlideCount} slides = ${finalScriptCount} scripts`);

        // üèóÔ∏è ASSEMBLAGE FINAL
        const slidesId = uuidv4();
        const totalTime = Date.now() - startTime;

        const result = {
            slides_id: slidesId,

            // R√âSULTATS PRINCIPAUX (Compatible format existant)
            markdown: slideMarkdown,
            narration_script: narrationScript,

            // üÜï INFORMATIONS SYNCHRONISATION
            synchronization_info: {
                markdown_slides_count: finalSlideCount,
                narration_scripts_count: finalScriptCount,
                synchronized: finalSlideCount === finalScriptCount,
                plan_sections_count: planData.plan_sections.length,
                mapping_type: finalSlideCount === planData.plan_sections.length ? '1:1' :
                    finalSlideCount > planData.plan_sections.length ? 'expanded' : 'compressed'
            },

            // INFORMATIONS RESSOURCES
            resource_integration: {
                files_used_in_markdown: resourcesAnalysis.files_content_integrated,
                company_context_applied: resourcesAnalysis.company_context_integrated,
                vocabulary_adapted: resourcesAnalysis.vocabulary_adapted,
                examples_from_files: resourcesAnalysis.extracted_examples,
                procedures_integrated: resourcesAnalysis.procedures_integrated,
                terminology_used: resourcesAnalysis.key_terminology
            },

            // COMPATIBILIT√â AVEC FORMAT EXISTANT
            slides_count: finalSlideCount,
            topic: planData.topic,
            source_plan_id: planData.plan_id,

            files: {
                markdown: `resource_slides_${slidesId}.md`,
                narration: `narration_${slidesId}.json`,
                script_txt: `script_${slidesId}.txt`
            },

            file_sizes: {
                markdown_kb: Math.round(slideMarkdown.length / 1024),
                narration_kb: Math.round(JSON.stringify(narrationScript).length / 1024)
            },

            slidev_commands: {
                preview: `slidev resource_slides_${slidesId}.md`,
                export_pdf: `slidev export resource_slides_${slidesId}.md --format pdf`,
                export_html: `slidev export resource_slides_${slidesId}.md --format html`
            },

            video_production: {
                total_duration_seconds: Object.values(narrationScript).reduce((sum, script) => sum + script.duration_seconds, 0),
                slides_with_timing: Object.keys(narrationScript).length,
                ready_for_recording: true,
                uses_company_terminology: resourcesAnalysis.vocabulary_adapted,
                references_uploaded_files: resourcesAnalysis.files_content_integrated,
                perfectly_synchronized: true
            },

            generation_time_ms: totalTime,
            generated_at: new Date().toISOString(),
            status: 'completed',
            ready_for_production: true,

            // Informations sur le provider utilis√©
            ai_provider: 'claude',
            model_used: process.env.CLAUDE_MODEL || 'claude-3-haiku-20240307',

            next_steps: {
                audio_generation: 'POST /ai/generate-narration-bark avec script synchronis√©',
                customization: resourcesAnalysis.company_context_integrated ?
                    'Contenu d√©j√† adapt√© √† votre contexte' :
                    'Personnaliser selon votre contexte'
            }
        };

        console.log(`‚úÖ G√©n√©ration compl√®te: ${finalSlideCount} slides synchronis√©es, ${resourcesAnalysis.total_files} fichiers int√©gr√©s, ${totalTime}ms`);
        res.json(result);

    } catch (error) {
        const totalTime = Date.now() - startTime;
        console.error('‚ùå Erreur plan-to-markdown:', error);
        res.status(500).json({
            error: 'Erreur g√©n√©ration markdown',
            generation_time_ms: totalTime,
            details: error.message,
            ai_provider: 'claude'
        });
    }
});

// üÜï FONCTIONS DE SYNCHRONISATION

function countActualSlides(markdown) {
    // Compter le nombre de slides r√©elles dans le markdown
    const slidesSeparators = markdown.match(/^---$/gm) || [];

    // Le premier --- est pour les m√©tadonn√©es, donc slides = separators - 1
    let slideCount = Math.max(1, slidesSeparators.length - 1);

    // Validation suppl√©mentaire avec les layouts
    const layoutsFound = markdown.match(/layout:\s*(intro|default|two-cols|center|end)/g) || [];

    // Si on trouve des layouts, utiliser ce nombre
    if (layoutsFound.length > 0) {
        slideCount = Math.max(slideCount, layoutsFound.length);
    }

    // Compter aussi les titres de slides (# titre)
    const titleSlides = markdown.match(/^#\s+.+$/gm) || [];
    if (titleSlides.length > slideCount) {
        slideCount = titleSlides.length;
    }

    console.log(`üìä D√©tection slides: separators=${slidesSeparators.length - 1}, layouts=${layoutsFound.length}, titles=${titleSlides.length}, final=${slideCount}`);

    return Math.max(slideCount, 1);
}

function forceSynchronization(narrationScript, targetCount, planData, resourcesAnalysis) {
    const currentCount = Object.keys(narrationScript).length;

    if (currentCount === targetCount) {
        return narrationScript; // D√©j√† synchronis√©
    }

    console.log(`üîß For√ßage synchronisation: ${currentCount} ‚Üí ${targetCount} scripts`);

    // Cr√©er nouveau script synchronis√©
    return createSynchronizedFallbackNarration(planData, resourcesAnalysis, targetCount);
}

function createSynchronizedFallbackNarration(planData, resourcesAnalysis, slideCount) {
    const { plan_sections } = planData;
    const narration = {};

    console.log(`üîß Cr√©ation narration synchronis√©e: ${slideCount} scripts pour ${plan_sections.length} sections`);

    for (let i = 0; i < slideCount; i++) {
        const slideKey = `slide_${i + 1}`;

        // Mapping intelligent sections ‚Üí slides
        let mappedSection;
        let sectionIndex;

        if (slideCount <= plan_sections.length) {
            // Moins ou √©gal de slides que de sections ‚Üí mapping direct ou combinaison
            sectionIndex = Math.floor(i * plan_sections.length / slideCount);
        } else {
            // Plus de slides que de sections ‚Üí subdivision
            sectionIndex = Math.floor(i * plan_sections.length / slideCount);
        }

        mappedSection = plan_sections[Math.min(sectionIndex, plan_sections.length - 1)];

        let tone = 'p√©dagogique';
        let title = mappedSection.title;
        let script = `Nous allons maintenant aborder ${mappedSection.title}.`;

        // D√©finir le ton selon la position
        if (i === 0) {
            tone = 'accueillant';
            title = mappedSection.title || 'Introduction';
            script = resourcesAnalysis.files_content_integrated ?
                `Bonjour et bienvenue dans cette formation sur ${title}, adapt√©e √† vos documents.` :
                `Bonjour et bienvenue dans cette formation sur ${title}.`;
        } else if (i === slideCount - 1) {
            tone = 'motivant';
            title = 'Conclusion';
            script = 'Pour conclure, retenez bien les points essentiels que nous venons de voir.';
        } else {
            // Slide interm√©diaire
            if (slideCount > plan_sections.length) {
                // Subdivision d'une section
                const partNumber = Math.floor(i / (slideCount / plan_sections.length)) + 1;
                title = `${mappedSection.title} - Partie ${partNumber}`;
                script = `Continuons avec ${mappedSection.title}. Nous allons maintenant voir les d√©tails importants.`;
            }
        }

        // Calculer dur√©e proportionnelle
        const baseDuration = mappedSection.duration_seconds || 60;
        const proportionalDuration = Math.floor(baseDuration * (plan_sections.length / slideCount));
        const adjustedDuration = Math.max(15, Math.min(120, proportionalDuration)); // Entre 15s et 2min

        narration[slideKey] = {
            title: title,
            duration_seconds: adjustedDuration,
            script: script,
            tone: tone,
            key_phrases: resourcesAnalysis.key_terminology.slice(0, 2) || ["Point important"],
            uses_resources: resourcesAnalysis.files_content_integrated,
            mapped_from_section: sectionIndex + 1,
            slide_position: i + 1,
            auto_generated: true // Flag pour indiquer g√©n√©ration automatique
        };
    }

    return narration;
}

// üîç ANALYSE DES RESSOURCES DISPONIBLES
function analyzeAvailableResources(planData) {
    const analysis = {
        total_files: 0,
        files_content_integrated: false,
        company_context_integrated: false,
        vocabulary_adapted: false,
        procedures_integrated: false,
        examples_extracted: false,
        key_terminology: [],
        extracted_examples: [],
        file_references: [],
        adaptation_quality: 'basic'
    };

    // Analyser les fichiers trait√©s
    if (planData.files_processing) {
        analysis.total_files = planData.files_processing.processed_successfully || 0;
        analysis.files_content_integrated = analysis.total_files > 0;

        if (planData.files_processing.processed_files) {
            planData.files_processing.processed_files.forEach(file => {
                if (file.status === 'parsed') {
                    analysis.file_references.push({
                        name: file.name,
                        type: file.content_type,
                        topics: file.key_topics
                    });

                    if (file.has_procedures) analysis.procedures_integrated = true;
                    if (file.has_examples) analysis.examples_extracted = true;
                    if (file.key_topics) analysis.key_terminology.push(...file.key_topics);
                }
            });
        }
    }

    // Analyser l'enrichissement
    if (planData.resources_enrichment) {
        analysis.company_context_integrated = planData.resources_enrichment.has_company_context;
        analysis.vocabulary_adapted = planData.resources_enrichment.adaptation_applied?.vocabulary_adapted || false;
    }

    // Extraire des sections du plan
    if (planData.plan_sections) {
        planData.plan_sections.forEach(section => {
            if (section.enhanced_with_resources) {
                if (section.key_terminology) {
                    analysis.key_terminology.push(...section.key_terminology);
                }
                if (section.examples_from_resources) {
                    analysis.extracted_examples.push(...section.examples_from_resources);
                }
            }
        });
    }

    // D√©duplication
    analysis.key_terminology = [...new Set(analysis.key_terminology.flat())].slice(0, 10);
    analysis.extracted_examples = [...new Set(analysis.extracted_examples.flat())].slice(0, 8);

    // Calcul qualit√©
    if (analysis.files_content_integrated && analysis.vocabulary_adapted && analysis.company_context_integrated) {
        analysis.adaptation_quality = 'excellent';
    } else if (analysis.files_content_integrated || analysis.vocabulary_adapted) {
        analysis.adaptation_quality = 'good';
    }

    return analysis;
}

// üé® CR√âATION PROMPT MARKDOWN ENRICHI
function createEnhancedMarkdownPrompt(planData, resourcesAnalysis) {
    const { topic, plan_sections, settings } = planData;
    const { level = 'beginner', duration = 5, style = 'practical' } = settings || {};

    let prompt = `Cr√©e un Markdown Slidev sophistiqu√© qui utilise les ressources fournies:

INFORMATIONS:
- Sujet: ${topic}
- Niveau: ${level}
- Dur√©e: ${duration} minutes
- Style: ${style}

RESSOURCES DISPONIBLES:
- Fichiers trait√©s: ${resourcesAnalysis.total_files}
- Contexte entreprise: ${resourcesAnalysis.company_context_integrated ? 'OUI' : 'NON'}
- Vocabulaire adapt√©: ${resourcesAnalysis.vocabulary_adapted ? 'OUI' : 'NON'}
- Proc√©dures: ${resourcesAnalysis.procedures_integrated ? 'OUI' : 'NON'}
- Exemples: ${resourcesAnalysis.examples_extracted ? 'OUI' : 'NON'}`;

    if (resourcesAnalysis.key_terminology.length > 0) {
        prompt += `\n\nTERMINOLOGIE √Ä UTILISER:\n${resourcesAnalysis.key_terminology.join(', ')}`;
    }

    if (resourcesAnalysis.extracted_examples.length > 0) {
        prompt += `\n\nEXEMPLES √Ä INT√âGRER:\n${resourcesAnalysis.extracted_examples.map((ex, i) => `${i + 1}. ${ex}`).join('\n')}`;
    }

    if (resourcesAnalysis.file_references.length > 0) {
        prompt += `\n\nFICHIERS √Ä R√âF√âRENCER:\n${resourcesAnalysis.file_references.map(ref => `- ${ref.name}: ${ref.type}`).join('\n')}`;
    }

    prompt += `\n\nSECTIONS DU PLAN:\n${plan_sections.map((section, i) => {
        return `${i + 1}. ${section.title} (${section.duration_seconds}s)\n   Points: ${section.what_to_cover ? section.what_to_cover.join(', ') : '√Ä d√©velopper'}`;
    }).join('\n\n')}`;

    prompt += `\n\nG√âN√àRE un Markdown Slidev enrichi avec int√©gration des ressources:

---
theme: ${resourcesAnalysis.company_context_integrated ? 'corporate' : 'academic'}
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%)
class: text-center
highlighter: shiki
lineNumbers: true
title: ${topic}
---

# ${topic}
## Formation ${duration} minutes${resourcesAnalysis.company_context_integrated ? ' - Adapt√©e √† votre contexte' : ''}

${resourcesAnalysis.files_content_integrated ? `
<div class="opacity-80 text-sm mt-4 bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg">
  üìö Formation enrichie par ${resourcesAnalysis.total_files} document(s)
</div>
` : ''}

<div class="pt-8">
  <span @click="$slidev.nav.next" class="px-6 py-3 rounded-lg cursor-pointer bg-gradient-to-r from-blue-500 to-purple-600 text-white font-semibold">
    üöÄ Commencer
  </span>
</div>

${plan_sections.map((section, index) => {
        if (section.type === 'introduction') {
            return `
---
layout: intro
---

# ${section.title}

${section.what_to_cover ? section.what_to_cover.map(point => `- **${point}**`).join('\n') : '- Introduction au sujet'}

${section.enhanced_with_resources && resourcesAnalysis.extracted_examples.length > 0 ? `
<div class="mt-6 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
  <h3 class="text-lg font-semibold mb-3 text-blue-700 dark:text-blue-300">
    üí° Bas√© sur vos ressources
  </h3>
  <div class="text-sm space-y-2">
${resourcesAnalysis.extracted_examples.slice(0, 2).map(example => `    <div>‚Ä¢ ${example}</div>`).join('\n')}
  </div>
</div>
` : ''}

<div class="mt-6">
  <div class="px-4 py-2 rounded-full bg-blue-100 text-blue-800 text-sm inline-block">
    ‚è±Ô∏è ${section.duration_seconds}s
  </div>
</div>`;

        } else if (section.type === 'development') {
            return `
---
layout: default
---

# ${section.title}

<div class="grid grid-cols-2 gap-8 mt-8">

<div class="space-y-4">

${section.what_to_cover ? section.what_to_cover.map((point, i) => `
## ${i + 1}. ${point}

${section.enhanced_with_resources ? `
<div class="text-sm text-blue-600 mb-4 bg-blue-50 p-2 rounded">
  üí° Point enrichi par vos documents
</div>
` : `
<div class="text-gray-600 text-sm mb-4">
  Point essentiel √† retenir
</div>
`}
`).join('') : '## Contenu principal'}

</div>

<div class="h-full">

${section.enhanced_with_resources && resourcesAnalysis.extracted_examples.length > 0 ? `
<div class="bg-green-50 p-6 rounded-xl h-full">
  <h3 class="text-lg font-semibold mb-4 text-green-700">
    üìã Exemples de vos documents
  </h3>
  <div class="space-y-3">
${resourcesAnalysis.extracted_examples.slice(0, 3).map(example => `    <div class="bg-white p-3 rounded-lg">
      <div class="text-sm">${example}</div>
    </div>`).join('\n')}
  </div>
</div>
` : `
<div class="bg-orange-50 p-6 rounded-xl h-full">
  <h3 class="text-lg font-semibold mb-2">Points Cl√©s</h3>
  <div class="text-sm">${section.content_summary || 'Contenu adapt√©'}</div>
</div>
`}

</div>

</div>

<div class="mt-8 p-4 bg-blue-50 rounded-lg">
  <div class="font-semibold">R√©sum√©</div>
  <div class="text-sm mt-1">${section.content_summary || 'Points cl√©s de cette section'}</div>
</div>`;

        } else if (section.type === 'conclusion') {
            return `
---
layout: center
class: text-center
---

# ${section.title}

<div class="max-w-4xl mx-auto">
  <div class="grid grid-cols-1 md:grid-cols-${section.what_to_cover ? Math.min(section.what_to_cover.length, 3) : 2} gap-6 mb-8">
${section.what_to_cover ? section.what_to_cover.map(point => `    <div class="bg-green-50 p-6 rounded-xl">
      <div class="text-3xl mb-3">‚úÖ</div>
      <div class="font-semibold text-green-700">${point}</div>
    </div>`).join('\n') : `    <div class="bg-green-50 p-6 rounded-xl">
      <div class="text-4xl mb-3">‚úÖ</div>
      <div class="font-semibold">R√©capitulatif</div>
    </div>
    <div class="bg-blue-50 p-6 rounded-xl">
      <div class="text-4xl mb-3">üöÄ</div>
      <div class="font-semibold">Prochaines √âtapes</div>
    </div>`}
  </div>

  ${section.enhanced_with_resources ? `
  <div class="bg-purple-100 p-6 rounded-xl mb-8">
    <h3 class="text-xl font-semibold mb-4 text-purple-700">
      üéØ Applications dans votre contexte
    </h3>
    <div class="text-sm text-purple-600">
      Cette formation a √©t√© adapt√©e √† vos ressources.
    </div>
  </div>
  ` : ''}

  <div class="pt-8">
    <span class="px-8 py-4 rounded-xl bg-gradient-to-r from-green-400 to-blue-500 text-white font-bold text-xl">
      üéâ Formation Termin√©e !
    </span>
  </div>
</div>`;
        }
        return '';
    }).join('')}

---
layout: end
---

# Merci !

<div class="text-center">
  <div class="text-6xl mb-4">üéâ</div>
  <div class="text-2xl">Formation ${topic} termin√©e</div>
  ${resourcesAnalysis.files_content_integrated ? `
  <div class="text-lg text-blue-600 mt-2">
    üìö Avec ${resourcesAnalysis.total_files} document(s) int√©gr√©(s)
  </div>
  ` : `
  <div class="text-lg text-gray-600 mt-2">Dur√©e: ${duration} minutes</div>
  `}
</div>

G√©n√®re UNIQUEMENT ce Markdown, rien d'autre.`;

    return prompt;
}

// üé¨ CR√âATION PROMPT NARRATION SYNCHRONIS√â
function createNarrationPrompt(planData, resourcesAnalysis, actualSlideCount) {
    const { topic, plan_sections, settings } = planData;
    const { level = 'beginner', duration = 5 } = settings || {};

    let prompt = `Cr√©e un script de narration adapt√© aux ressources et PARFAITEMENT synchronis√©:

FORMATION:
- Sujet: ${topic}
- Niveau: ${level}
- Dur√©e: ${duration} minutes
- NOMBRE DE SLIDES EXACT: ${actualSlideCount}

ADAPTATION RESSOURCES:
- Fichiers: ${resourcesAnalysis.total_files}
- Vocabulaire adapt√©: ${resourcesAnalysis.vocabulary_adapted ? 'OUI' : 'NON'}
- Exemples sp√©cifiques: ${resourcesAnalysis.examples_extracted ? 'OUI' : 'NON'}`;

    if (resourcesAnalysis.key_terminology.length > 0) {
        prompt += `\n\nTERMINOLOGIE √Ä UTILISER: ${resourcesAnalysis.key_terminology.join(', ')}`;
    }

    prompt += `\n\nSECTIONS DISPONIBLES:\n${plan_sections.map((section, i) =>
        `${i + 1}. ${section.title} (${section.duration_seconds}s) - ${section.type}`
    ).join('\n')}`;

    prompt += `\n\n‚ö†Ô∏è CRITICAL: Tu dois g√©n√©rer EXACTEMENT ${actualSlideCount} scripts de narration.

R√àGLES DE MAPPING:
- Si ${actualSlideCount} slides > ${plan_sections.length} sections : Diviser les sections longues
- Si ${actualSlideCount} slides < ${plan_sections.length} sections : Combiner certaines sections  
- Si ${actualSlideCount} slides = ${plan_sections.length} sections : Mapping 1:1 parfait

G√âN√àRE ce JSON avec EXACTEMENT ${actualSlideCount} entr√©es:

{
${Array.from({ length: actualSlideCount }, (_, index) => {
        const slideKey = `slide_${index + 1}`;
        let sectionIndex;

        if (actualSlideCount <= plan_sections.length) {
            sectionIndex = Math.floor(index * plan_sections.length / actualSlideCount);
        } else {
            sectionIndex = Math.floor(index * plan_sections.length / actualSlideCount);
        }

        const mappedSection = plan_sections[Math.min(sectionIndex, plan_sections.length - 1)];

        let tone = 'p√©dagogique';
        let title = mappedSection.title;

        if (index === 0) {
            tone = 'accueillant';
            title = mappedSection.title || 'Introduction';
        } else if (index === actualSlideCount - 1) {
            tone = 'motivant';
            title = 'Conclusion';
        } else if (actualSlideCount > plan_sections.length) {
            const partNumber = Math.floor((index - 1) / Math.ceil(actualSlideCount / plan_sections.length)) + 1;
            title = `${mappedSection.title} - Partie ${partNumber}`;
        }

        const baseDuration = mappedSection.duration_seconds || 60;
        const proportionalDuration = Math.floor(baseDuration * (plan_sections.length / actualSlideCount));
        const adjustedDuration = Math.max(15, Math.min(120, proportionalDuration));

        return `  "${slideKey}": {
    "title": "${title}",
    "duration_seconds": ${adjustedDuration},
    "script": "Script adapt√© pour ${title}. ${resourcesAnalysis.vocabulary_adapted ? 'Utiliser la terminologie sp√©cialis√©e.' : ''} ${resourcesAnalysis.examples_extracted ? 'Mentionner les exemples des documents.' : ''}",
    "tone": "${tone}",
    "key_phrases": ${resourcesAnalysis.key_terminology.length > 0 ? JSON.stringify(resourcesAnalysis.key_terminology.slice(0, 2)) : '["point important"]'},
    "uses_resources": ${resourcesAnalysis.files_content_integrated}
  }`;
    }).join(',\n')}
}

R√àGLES:
- Ton naturel et ${resourcesAnalysis.company_context_integrated ? 'professionnel' : 'conversationnel'}
- ${resourcesAnalysis.vocabulary_adapted ? 'Utiliser OBLIGATOIREMENT la terminologie fournie' : 'Langage accessible'}
- ${resourcesAnalysis.examples_extracted ? 'Int√©grer les exemples des documents' : 'Exemples g√©n√©riques'}

G√©n√®re UNIQUEMENT ce JSON avec EXACTEMENT ${actualSlideCount} scripts, rien d'autre.`;

    return prompt;
}

// üîß FONCTIONS UTILITAIRES

function cleanMarkdown(markdown) {
    return markdown
        .replace(/```markdown\n/g, '')
        .replace(/\n```/g, '')
        .replace(/```/g, '')
        .trim();
}

function cleanNarrationResponse(response) {
    return response
        .replace(/```json\n/g, '')
        .replace(/\n```/g, '')
        .replace(/```/g, '')
        .replace(/^[^{]*/, '')
        .replace(/[^}]*$/, '')
        .trim();
}

// üîß CR√âATION FALLBACK MARKDOWN CORRIG√â
function createFallbackMarkdown(planData, resourcesAnalysis) {
    const { topic, plan_sections, settings } = planData;
    const { duration = 5 } = settings || {};

    return `---
theme: academic
background: linear-gradient(45deg, #1e3c72, #2a5298)
class: text-center
title: ${topic}
---

# ${topic}
## Formation ${duration} minutes

${resourcesAnalysis.files_content_integrated ? `
<div class="text-sm mt-4 bg-blue-50 p-3 rounded">
  üìö Formation enrichie par ${resourcesAnalysis.total_files} document(s)
</div>
` : ''}

<div class="pt-12">
  <span @click="$slidev.nav.next" class="px-6 py-3 rounded-lg cursor-pointer bg-blue-600 text-white">
    üöÄ Commencer
  </span>
</div>

${plan_sections.map(section => {
        return `
---
layout: default
---

# ${section.title}

<div class="max-w-4xl mx-auto mt-8">

<div class="space-y-6">
${section.what_to_cover ? section.what_to_cover.map(point => `
<div class="bg-white p-4 rounded-lg border-l-4 border-blue-500">
  <div class="font-semibold text-gray-800">‚Ä¢ ${point}</div>
</div>`).join('') : `
<div class="bg-white p-4 rounded-lg border-l-4 border-blue-500">
  <div class="font-semibold text-gray-800">‚Ä¢ Contenu √† d√©velopper</div>
</div>`}
</div>

${section.enhanced_with_resources ? `
<div class="mt-8 p-6 bg-blue-50 rounded-xl">
  <h3 class="text-lg font-semibold mb-2 text-blue-700">üí° Adapt√© √† vos ressources</h3>
  <div class="text-sm text-blue-600">${section.content_summary || 'Contenu personnalis√©'}</div>
</div>
` : `
<div class="mt-8 p-4 bg-gray-50 rounded-lg">
  <div class="text-sm text-gray-600">
    ‚è±Ô∏è ${section.duration_seconds}s ‚Ä¢ ${section.type}
  </div>
</div>
`}

</div>`;
    }).join('')}

---
layout: end
---

# Merci !

<div class="text-center">
  <div class="text-6xl mb-4">üéâ</div>
  <div class="text-2xl">Formation ${topic} termin√©e</div>
  <div class="text-lg text-gray-600 mt-2">Dur√©e: ${duration} minutes</div>
</div>`;
}

// üîß ROUTE SAUVEGARDE
router.post('/save-files', async (req, res) => {
    try {
        const { markdown, narration_script, slides_id } = req.body;

        if (!markdown) {
            return res.status(400).json({
                error: 'Le champ "markdown" est requis'
            });
        }

        const slidesDir = path.join(__dirname, '..', '..', 'generated-slides');
        await fs.mkdir(slidesDir, { recursive: true });

        const baseFilename = slides_id || `resource_slides_${Date.now()}`;
        const savedFiles = [];

        // Sauvegarder markdown
        const markdownFile = `${baseFilename}.md`;
        const markdownPath = path.join(slidesDir, markdownFile);
        await fs.writeFile(markdownPath, markdown, 'utf8');
        savedFiles.push(markdownFile);

        // Sauvegarder script narration
        if (narration_script) {
            const narrationFile = `narration_${baseFilename}.json`;
            const narrationPath = path.join(slidesDir, narrationFile);
            await fs.writeFile(narrationPath, JSON.stringify(narration_script, null, 2), 'utf8');
            savedFiles.push(narrationFile);

            // Script texte
            const scriptText = Object.entries(narration_script)
                .map(([slide, data]) => `=== ${data.title} (${data.duration_seconds}s) ===\n${data.script}\n`)
                .join('\n');

            const scriptFile = `script_${baseFilename}.txt`;
            const scriptPath = path.join(slidesDir, scriptFile);
            await fs.writeFile(scriptPath, scriptText, 'utf8');
            savedFiles.push(scriptFile);
        }

        res.json({
            message: 'Fichiers sauv√©s avec succ√®s',
            saved_files: savedFiles,
            directory: slidesDir,
            slidev_command: `cd generated-slides && slidev ${markdownFile}`,
            ai_provider: 'claude'
        });

    } catch (error) {
        res.status(500).json({
            error: 'Erreur sauvegarde',
            details: error.message,
            ai_provider: 'claude'
        });
    }
});

// üîß ROUTE INFO
router.get('/plan-to-markdown/info', (req, res) => {
    res.json({
        endpoint: 'POST /ai/plan-to-markdown',
        description: 'Convertit le plan en Markdown Slidev enrichi avec synchronisation parfaite slides/narration',
        version: '5.1 - Perfect Synchronization + Claude API',
        status: '‚úÖ OP√âRATIONNEL',
        ai_provider: 'claude',
        model: process.env.CLAUDE_MODEL || 'claude-3-haiku-20240307',

        fonctionnalit√©s: [
            'üîÑ Synchronisation automatique slides ‚Üî scripts narration',
            'üìö Utilisation intelligente des fichiers upload√©s',
            'üé¨ Scripts de narration adapt√©s au vocabulaire',
            'üè¢ Adaptation automatique au contexte entreprise',
            'üîë Int√©gration terminologie sp√©cifique',
            'üí° Exemples personnalis√©s des documents',
            'üìä Validation et correction automatique des d√©synchronisations',
            'üîß Correction structure two-cols Slidev',
            'ü§ñ Migration vers Claude API pour meilleure qualit√©'
        ],

        synchronization_features: [
            '‚úÖ D√©tection automatique du nombre de slides markdown',
            'üîß Ajustement forc√© du nombre de scripts narration',
            'üìà Mapping intelligent sections ‚Üí slides',
            '‚öñÔ∏è R√©partition proportionnelle des dur√©es',
            'üîç Validation finale de synchronisation'
        ],

        claude_integration: [
            'üöÄ API Claude Anthropic pour g√©n√©ration de haute qualit√©',
            '‚ö° Configuration via variables d\'environnement',
            'üîß Headers API corrects (x-api-key, anthropic-version)',
            'üìù Format de message adapt√© √† Claude',
            'üõ°Ô∏è Gestion d\'erreurs robuste',
            'üìä Tracking du provider utilis√© dans les r√©ponses'
        ],

        workflow: [
            '1. POST /ai/groq-plan (avec ressources/fichiers)',
            '2. POST /ai/plan-to-markdown (g√©n√®re markdown + compte slides)',
            '3. G√©n√©ration narration avec nombre exact de scripts',
            '4. Validation synchronisation finale',
            '5. POST /ai/generate-narration-bark (audio parfaitement align√©)'
        ],

        environment_variables: [
            'USE_CLAUDE=true',
            'CLAUDE_API_KEY=sk-ant-api03-...',
            'CLAUDE_MODEL=claude-3-haiku-20240307'
        ],

        api_changes: {
            from_groq: {
                url: 'https://api.groq.com/openai/v1/chat/completions',
                headers: ['Authorization: Bearer', 'Content-Type'],
                format: 'OpenAI compatible'
            },
            to_claude: {
                url: 'https://api.anthropic.com/v1/messages',
                headers: ['x-api-key', 'anthropic-version', 'content-type'],
                format: 'Claude native format'
            }
        },

        compatibilit√©: {
            format_entr√©e: 'Compatible avec tous les plans existants',
            format_sortie: 'Format enrichi + info provider Claude',
            r√©trocompatible: 'Fonctionne avec plans sans ressources',
            guaranteed_sync: 'Synchronisation garantie √† 100%',
            slidev_compliant: 'Markdown Slidev valide sans erreurs Vue.js'
        }
    });
});

// üß™ ROUTE DE TEST SYNCHRONISATION
router.post('/test-synchronization', async (req, res) => {
    try {
        const { markdown, plan_sections } = req.body;

        if (!markdown || !plan_sections) {
            return res.status(400).json({
                error: 'markdown et plan_sections requis'
            });
        }

        const slideCount = countActualSlides(markdown);
        const sectionCount = plan_sections.length;

        // Test de synchronisation
        const mockResourcesAnalysis = {
            total_files: 0,
            vocabulary_adapted: false,
            files_content_integrated: false,
            key_terminology: [],
            extracted_examples: []
        };

        const syncedNarration = createSynchronizedFallbackNarration(
            { plan_sections },
            mockResourcesAnalysis,
            slideCount
        );

        res.json({
            test_results: {
                detected_slides: slideCount,
                plan_sections: sectionCount,
                generated_scripts: Object.keys(syncedNarration).length,
                synchronized: Object.keys(syncedNarration).length === slideCount
            },
            mapping_analysis: {
                type: slideCount === sectionCount ? '1:1' :
                    slideCount > sectionCount ? 'expansion' : 'compression',
                ratio: Math.round((slideCount / sectionCount) * 100) / 100
            },
            generated_narration: syncedNarration,
            ai_provider: 'claude',
            success: true
        });

    } catch (error) {
        res.status(500).json({
            error: 'Erreur test synchronisation',
            details: error.message,
            ai_provider: 'claude'
        });
    }
});

// üîß ROUTE DE SANT√â POUR CLAUDE
router.get('/health/claude', async (req, res) => {
    try {
        // Test simple de connectivit√© Claude
        const testResponse = await callClaude('R√©ponds simplement "OK"', {
            max_tokens: 10
        });

        res.json({
            status: 'healthy',
            ai_provider: 'claude',
            model: process.env.CLAUDE_MODEL || 'claude-3-haiku-20240307',
            api_reachable: true,
            test_response: testResponse.trim(),
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        res.status(500).json({
            status: 'unhealthy',
            ai_provider: 'claude',
            api_reachable: false,
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

module.exports = router;